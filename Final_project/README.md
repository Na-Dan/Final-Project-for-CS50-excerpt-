# Which degree of Kevin Bacon?
### Video Demo: https://youtu.be/zXhtC9Aat2E
### Description:
This program is an hommage to the parlor game "Six degrees of Kevin Bacon". The game begins by randomly choosing an actress or actor and then connecting them to another actress / actor via a movie both starred in - repeating this process until finding (the shortest path to) a movie in which Kevin Bacon also starred. The number of movies it takes to get to Kevin Bacon determines the degree of connection the initial actress or actor have to the eponym of the game.

This program opens a website on which the user can start playing by clicking on "let's play" and then entering the name of the actress / actor who is the initial star into a form and submitting it by clicking on the button "Find the Bacon!" or hitting enter. In case the name is ambigious, the user is asked to add the birth year of the person searched for and submit the form. If no errors with the input occur (e.g. name invalid or unknown), the website either shows the results in rows saying "person x played in movie y with person z", "person z played in movie a with person b" and so forth, ending in "Kevin Bacon", or asks the user to wait for the results to be displayed, which can take up to 25 min. Due to the restrictions of the program, the results might come up empty, informing the user that the program is not suited for finding a connection between the initial actress / actor and Kevin Bacon.

**Please note**:

**1.** This program uses <code>Python</code>, <code>Flask</code>, the <code>movies.db</code> from CS50 Week 7 on SQL as well as styles.css and basic formats for (jinja) templates from CS50 Week 9 on Flask - especially the <code>apology.html</code> with the grumpy cat.

**2.** The employed <code>movies.db</code> is **not** the same as the IMDb, therefore the results (i.e. degrees shown in the end) may deviate from actual connections - especially considering that the stars listed for a movie (being the basis for the search) sometimes only encompass 4 people, whereas many more played (minor) roles in the same movie.

**3.** As the timeout for the GitHub codespace is 30 min, any search taking longer than 25 min (5 min buffer for input validation and output) and not yielding any results leads to an empty result - informing the user that the program is not suited for finding the connection between the initial star and Kevin Bacon.

**4.** The design of the website is minimalistic by choice - the code running in the background took priority and the main job of the website is to work rather than appeal.

### Files of this program:
- flask session
- static
- templates
- app.py
- cache.json
- movies.db

### How they work:
- Several global variables help keeping track of the search progress:
    - <code>results</code> saves the degrees it takes to get to Kevin Bacon. It is a <code>list</code> of <code>dict</code>s, in which each hop (i.e. <code>dict</code>) leading closer to Kevin Bacon is prepended to the list as an item in the strutcure <code>{root_id: [star_id, movie_id]}</code>. In case a search does not yield any connection, <code>results</code> remains an empty <code>list</code> that is also saved.
    - <code>cache.json</code> is a file that saves all <code>results</code>. This file is openend at the beginning of the program as a <code>dict</code> with the same name and has the structure <code>{'star_id': [<code>results</code>]}</code>.
    - <code>p_search</code> is a Python Process-object that allows multiprocessing --> continuing the search in the background while already returning a template that asks the user to wait for the results. As mentioned, the search can take up to 25 min, which would lead to a timeout between the website waiting for a response and the server running the search in the background. Multiprocessing helps circumvent this issue.
    - <code>queue</code> is a <code>list</code> of <code>star_id</code>s to run through during the search. It helps the search to run in a <span style="color:fuchsia">**breadth first**</span> manner, meaning: The structure of connections is similar to a tree structure -->  1 star : n movies (branches), each of which leads to n other stars, who have n movies and so forth. In order to move vertically (i.e. checking all movies of one star first) before continuing the process one level further horizontally, the sequence of the search needs to be determined. Therefore, the search is designed to first run through the list of movies in which Kevin Bacon starred and <code>queue</code> all stars per movie. These are checked for connections to the initial star first. Only if nothing is found in this level of the tree structure, the search moves on to repeating the <code>queue</code>-ing process for all the stars in all the movies in which Kevin Bacon played etc. <code>queue</code> is filtered to only include <code>star_id</code>s that have not yet been checked (in case a person starred in several movies in several levels of the tree, an already futile search should not be repeated). This is tracked in the last global variable:
    - <code>already_searched</code> is a <code>list</code> of <code>star_id</code>s that have already been checked within the search and therefore have been popped from <code>queue</code>, marking those that can be skipped (which is checked before doing any search).

- The function <code>direct_connection()</code> is a corner stone of the program and is called by other functions in different scenarios.
    - It takes 2 parameters: <code>star_id</code> and <code>root_id</code>, the latter being the ID of the star to whom a connection is checked.
    - The function queries <code>movies.db</code> for a movie in which both <code>star_id</code> and <code>root_id</code> have starred. In case there is such a movie, the function fills <code>results</code> according to the schema above and returns <code>True</code>. Otherwise it returns <code>False</code>.
-  <code>app.py</code> has 2 routes: <code>("/")</code> rendering the website layout and <code>("/search")</code> rendering the template <code>search.html</code> if there is a <code>get.request</code> or starting the game (= search) if the user has submitted (<code>post.request)</code> the form (either only name or name and birth year of the initial star).
    - <code>"/search"</code> **first does 3 input validations**:
        - The submitted string (i.e. star name, restricted to <code>text</code> as input type in the form) must not be empty. If it is, the route returns an <code>apology.html</code> with the grumpy cat from CS50 Week 9, asking the user to enter a (valid) name.
        - The sumbitted string minus spaces may only contain certain characters (Roman alphabet as well as diphtongues and other letters possible in names) whose ASCII values are stored in the global list <code>allowed_characters</code>, against which the route checks the input. In case the input contains characters not allowed, the route returns an <code>apology.html</code> with the grumpy cat from CS50 Week 9, asking the user to enter a (valid) name.
        - In case the user chose "Kevin Bacon" as the initial star, the route returns the grumpy cat from CS50 Week 9, saying "Ha. Ha."
    - <code>"/search"</code> **then tries identifying the <code>star_id</code> of the input** (i.e. her or his ID in the <code>movies.db</code>)
        - If the validated name yields more than 1 ID (from here on <code>star_id</code>) in <code>movies.db</code>, the route returns the template <code>search_with_year.html</code>, asking the user to add a birth year for the initial star.
        - In case the user sumbitted the form with a birth year (restricted to <code>number</code> as input type), the route first checks whether the post was not empty and consisted of 4 characters. If not, the route returns an <code>apology.html</code>, asking the user to rectify the input.
        - In case the name (or name and birth year) do not yield any results in <code>movies.db</code>, the route returns an <code>apology.html</code>, informing the user that the database does know this person.
    - <code>"/search"</code> **then tries <span style="color:limegreen">2 options</span> for finding <code>results</code> quickly:**
        - Checking if <code>str(star_id)</code> is already in <code>cache.json</code> (keys are strings in json-files). If this is the case (also with empty <code>results</code>), the list <code>results</code> is passed to the function <code>printing_the_results</code> that returns another list of <code>transformed_results</code>, containing star-names and movie-titles instead of IDs. Together with the variables degree = <code>len(results)</code> and initial_star = the name belonging to the determined <code>star_id</code> of the input, the <code>transformed_results</code> are passed to returning the template <code>results.html</code> that either shows the degree of connection and specifies in rows "person x played in movie y with person z", "person z played in movie a with person b" and so forth, ending in "Kevin Bacon" or an aopology (if <code>results</code> are empty due to too much time needed to run the program). <span style="color:blue"> In case the existence of <code>results</code> in <code>cache.json</code> is due to <code>p_search</code> having run in the background, the process will be stopped at this point. </span>
        - Checking if there is a direct connection between the initial star and Kevin Bacon through the function <code>direct_connection</code>. <code>"/search"</code> passes the <code>star_id</code> and Kevin Bacon's ID = 102 as <code>root_id</code> to the function for this purpose.

    - <code>"/search"</code> **proceeds to a thorough search if there are no quick <code>results</code>:**

        - The route first checks whether <code>p_search</code> is running. If it is, it returns either the template. <code>please_wait_search.html</code> or the template <code>please_wait_search_with_year.html</code> - two templates that receive either the star name **OR** the name and birth year as parameters that are then autocompleted into the form of either template. Using <code>javascript</code>, the form keeps auto-submitting the the content to <code>"/search"</code> every 60 sec until the <code>results</code> are in <code>cache.json</code> and can be accessed by one of the <span style="color:limegreen">**2 options**</span> the route checks first when being called by the automatic <code>post.requests</code>. <span style="color:blue">As above, <code>p_search</code> might be stopped in these options.</span>
        - If <code>p_search</code> is not running yet, the route starts it with the function <code>do_the_search()</code> as the target **AND** returns the template <code>please_wait_search.html</code> or the template <code>please_wait_search_with_year.html</code> - with the same functionalities as above.
- <code>do_the_search()</code> orchestrates the <span style="color:fuchsia">**breadth first**</span> search through the <code>movies.db</code> including "retrieving" the intermediate results (hops it takes to get to Kevin Bacon):
    - The function takes the identified <code>star_id</code> of the initial star as a parameter.
    - The function first adds all stars from all of Kevin Bacon's movies to <code>queue</code> by calling the helper function <code>queue_Bacons_movie_stars()</code>.
    - As long as <code>queue</code> contains something **and** the time delta between the program starting to run and the function call does not exceed 25 min (if so, it returns an empty <code>results</code> and updates <code>cache.json</code>) the following happens:
        - The function checks every star in <code>queue</code> for a possible connection to <code>star_id</code> by checking whether the function <code>search_on()</code> (that takes the first item in <code>queue</code> and the <code>star_id</code> of the initial star as parameters) returns <code>True</code>.
            - This only happens if <code>direct_connection()</code> to whom <code>search_on()</code> passes its parameters returns <code>True</code> (and with this fills the <code>results</code>) - meaning that finally, down the many branches of the tree structure, a connection has been found between the input from the user and possible branches leading to Kevin Bavon.
                - At this point, the function needs to "retrace" it's steps back horizontally through the tree. This done by browsing through <code>already_checked</code> in search for a <code>direct_connection()</code> between the elements of the <code>results</code> and <code>already_checked</code>.
                - All of the <code>results</code> found during the "retrace" process are saved in <code>cache.json</code> and the function returns.
            - Otherwise (as it was called by <code>do_the_search()</code>) <code>search_on()</code> proceeds to create a <code>list</code> of movies that the first item in <code>queue</code> (passed to this function as parameter) played in and, using this list, adds all stars from these movies to <code>queue</code> - unless it's the same ID as the current first item in <code>queue</code> that was passed on to it or this ID is in <code>already_checked</code>.
        - Having checked the current item from <code>queue</code>, the function pops this item (i.e. the first index-position from <code>queue</code>).
